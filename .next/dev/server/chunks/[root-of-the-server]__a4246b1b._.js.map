{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/PMLS/Videos/foodapp/app/api/solvers/transportation/route.ts"],"sourcesContent":["import { type NextRequest, NextResponse } from \"next/server\"\n\nfunction vogelsApproximationMethod(\n  costMatrix: number[][],\n  supply: number[],\n  demand: number[],\n): { allocation: number[][]; totalCost: number } {\n  const m = supply.length\n  const n = demand.length\n  const allocation = Array(m)\n    .fill(0)\n    .map(() => Array(n).fill(0))\n\n  const supplyLeft = [...supply]\n  const demandLeft = [...demand]\n  const usedCells = new Set<string>()\n\n  // VAM implementation\n  let iteration = 0\n  while (supplyLeft.some((s) => s > 0) && demandLeft.some((d) => d > 0) && iteration < 1000) {\n    iteration++\n\n    // Calculate penalties for each row and column\n    const rowPenalties: number[] = []\n    for (let i = 0; i < m; i++) {\n      if (supplyLeft[i] > 0) {\n        const costs = costMatrix[i]\n          .map((c, j) => (demandLeft[j] > 0 ? c : Number.MAX_SAFE_INTEGER))\n          .filter((c) => c !== Number.MAX_SAFE_INTEGER)\n        if (costs.length >= 2) {\n          costs.sort((a, b) => a - b)\n          rowPenalties.push(costs[1] - costs[0])\n        } else if (costs.length === 1) {\n          rowPenalties.push(costs[0])\n        } else {\n          rowPenalties.push(0)\n        }\n      } else {\n        rowPenalties.push(-1)\n      }\n    }\n\n    const colPenalties: number[] = []\n    for (let j = 0; j < n; j++) {\n      if (demandLeft[j] > 0) {\n        const costs = costMatrix\n          .map((row) => row[j])\n          .map((c, i) => (supplyLeft[i] > 0 ? c : Number.MAX_SAFE_INTEGER))\n          .filter((c) => c !== Number.MAX_SAFE_INTEGER)\n        if (costs.length >= 2) {\n          costs.sort((a, b) => a - b)\n          colPenalties.push(costs[1] - costs[0])\n        } else if (costs.length === 1) {\n          colPenalties.push(costs[0])\n        } else {\n          colPenalties.push(0)\n        }\n      } else {\n        colPenalties.push(-1)\n      }\n    }\n\n    // Find cell with maximum penalty\n    let maxPenalty = -1\n    let maxI = -1\n    let maxJ = -1\n    let isRow = true\n\n    for (let i = 0; i < m; i++) {\n      if (rowPenalties[i] > maxPenalty) {\n        maxPenalty = rowPenalties[i]\n        maxI = i\n        isRow = true\n      }\n    }\n\n    for (let j = 0; j < n; j++) {\n      if (colPenalties[j] > maxPenalty) {\n        maxPenalty = colPenalties[j]\n        maxJ = j\n        isRow = false\n      }\n    }\n\n    // Find minimum cost cell in selected row/column\n    if (isRow && maxI !== -1) {\n      let minCost = Number.POSITIVE_INFINITY\n      for (let j = 0; j < n; j++) {\n        if (demandLeft[j] > 0 && costMatrix[maxI][j] < minCost) {\n          minCost = costMatrix[maxI][j]\n          maxJ = j\n        }\n      }\n    } else if (!isRow && maxJ !== -1) {\n      let minCost = Number.POSITIVE_INFINITY\n      for (let i = 0; i < m; i++) {\n        if (supplyLeft[i] > 0 && costMatrix[i][maxJ] < minCost) {\n          minCost = costMatrix[i][maxJ]\n          maxI = i\n        }\n      }\n    }\n\n    // Allocate\n    if (maxI !== -1 && maxJ !== -1 && supplyLeft[maxI] > 0 && demandLeft[maxJ] > 0) {\n      const quantity = Math.min(supplyLeft[maxI], demandLeft[maxJ])\n      allocation[maxI][maxJ] += quantity\n      supplyLeft[maxI] -= quantity\n      demandLeft[maxJ] -= quantity\n      usedCells.add(`${maxI},${maxJ}`)\n    } else {\n      break\n    }\n  }\n\n  // Calculate total cost\n  let totalCost = 0\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      totalCost += allocation[i][j] * costMatrix[i][j]\n    }\n  }\n\n  return { allocation, totalCost }\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await request.json()\n    const { num_supply, num_demand, cost_matrix, supply, demand } = body\n\n    const { allocation, totalCost } = vogelsApproximationMethod(cost_matrix, supply, demand)\n\n    return NextResponse.json({\n      status: \"Optimal\",\n      total_cost: totalCost,\n      allocation: allocation,\n      is_balanced: supply.reduce((a, b) => a + b, 0) === demand.reduce((a, b) => a + b, 0),\n    })\n  } catch (error) {\n    return NextResponse.json(\n      { status: \"Error\", error_message: String(error), total_cost: null, allocation: null },\n      { status: 400 },\n    )\n  }\n}\n"],"names":[],"mappings":"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"}}]
}